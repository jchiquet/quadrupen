% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/quadrupen-class.R, R/quadrupen-R6Class.R
\docType{methods}
\name{criteria,quadrupen-method}
\alias{criteria,quadrupen-method}
\alias{criteria.quadrupen}
\alias{criteria}
\alias{QuadrupenFit}
\title{Penalized criteria based on estimation of degrees of freedom}
\usage{
criteria(object, penalty=setNames(c(2, log(p)), c("AIC","BIC")), sigma=NULL,
           log.scale=TRUE, xvar = "lambda", plot=TRUE)

plot.quadrupen(x, y, xvar = "lambda",
        main = private$penalty," path", sep=""),
        log.scale = TRUE, standardize=TRUE, reverse=FALSE,
        labels = NULL, plot = TRUE, ...)

criteria(object, penalty=setNames(c(2, log(p)), c("AIC","BIC")), sigma=NULL,
           log.scale=TRUE, xvar = "lambda", plot=TRUE)
}
\arguments{
\item{object}{output of a fitting procedure of the \pkg{quadrupen}
package (e.g. \code{\link{elastic.net}}). Must be of class
\code{quadrupen}.}

\item{penalty}{a vector with as many penalties a desired. The
default contains the penalty corresponding to the AIC and the BIC
(\eqn{2}{2} and \eqn{\log(n)}{log(n)}). Setting the "names"
attribute, as done in the default definition, leads to outputs
which are easier to read.}

\item{sigma}{scalar: an estimate of the residual variance. When
available, it is plugged-in the criteria, which may be more
relevant. If \code{NULL} (the default), it is estimated as usual
(see details).}

\item{log.scale}{logical; indicates if a log-scale should be used
when \code{xvar="lambda"}. Default is \code{TRUE}.}

\item{xvar}{variable to plot on the X-axis: either \code{"df"}
(the estimated degrees of freedom), \code{"lambda"}
(\eqn{\lambda_1}{lambda1} penalty level) or \code{"fraction"}
(\eqn{\ell_1}{l1}-norm of the coefficients). Default is set to
\code{"lambda"}.}

\item{plot}{logical; indicates if the graph should be plotted on
call. Default is \code{TRUE}.}
}
\value{
When \code{plot} is set to \code{TRUE}, an invisible
\pkg{ggplot2} object is returned, which can be plotted via the
\code{print} method. On the other hand, a list with a two data
frames containing the criteria and the chosen vector of parameters
are returned.
}
\description{
Produce a plot or send back the values of some penalized criteria
accompanied with the vector(s) of parameters selected
accordingly. The default behavior plots the BIC and the AIC (with
respective factor \eqn{\log(n)}{log(n)} and \eqn{2}{2}) yet the user can specify any
penalty.
}
\details{
Class of object returned by any fitting function of the
\pkg{quadrupen} package (\code{elastic.net} or
\code{bounded.reg}).

This class comes with the usual \code{predict(object, newx, ...)},
\code{fitted(object, ...)}, \code{residuals(object, ...)},
\code{print(object, ...)}, \code{show(object)} and
\code{deviance(object, ...)} generic (undocumented) methods.

A specific plotting method is available and documented
(\code{\link{plot.quadrupen}}).
}
\note{
When \code{sigma} is provided, the criterion takes the form

\if{latex}{\deqn{\left\|\mathbf{y} - \mathbf{X} \hat{\beta} \right\|^2 +
\mathrm{penalty} \times \frac{\hat{\mathrm{df}}}{n} \ \sigma^2.}}
\if{html}{\out{ <center> RSS + penalty * df / n * sigma<sup>2</sup> </center>}}
\if{text}{\deqn{RSS + penalty * df / n * sigma^2}}

When it is unknown, it writes

\if{latex}{\deqn{\log\left(\left\|\mathbf{y} - \mathbf{X} \hat{\beta} \right\|^2\right) +
\mathrm{penalty} \times \hat{\mathrm{df}}.}}
\if{html}{\out{ <center> n*log(RSS) + penalty * df </center>}}
\if{text}{\deqn{n*log(RSS) + penalty * df}}

Estimation of the degrees of freedom (for the elastic-net, the
LASSO and also bounded regression) are computed by applying and
adpating the results of Tibshirani and Taylor (see references
below).

When \code{sigma} is provided, the criterion takes the form

\if{latex}{\deqn{\left\|\mathbf{y} - \mathbf{X} \hat{\beta} \right\|^2 +
\mathrm{penalty} \times \frac{\hat{\mathrm{df}}}{n} \ \sigma^2.}}
\if{html}{\out{ <center> RSS + penalty * df / n * sigma<sup>2</sup> </center>}}
\if{text}{\deqn{RSS + penalty * df / n * sigma^2}}

When it is unknown, it writes

\if{latex}{\deqn{\log\left(\left\|\mathbf{y} - \mathbf{X} \hat{\beta} \right\|^2\right) +
\mathrm{penalty} \times \hat{\mathrm{df}}.}}
\if{html}{\out{ <center> n*log(RSS) + penalty * df </center>}}
\if{text}{\deqn{n*log(RSS) + penalty * df}}

Estimation of the degrees of freedom (for the elastic-net, the
LASSO and also bounded regression) are computed by applying and
adpating the results of Tibshirani and Taylor (see references
below).
}
\examples{
\dontrun{
## Simulating multivariate Gaussian with blockwise correlation
## and piecewise constant vector of parameters
beta <- rep(c(0,1,0,-1,0), c(25,10,25,10,25))
cor <- 0.75
Soo <- toeplitz(cor^(0:(25-1))) ## Toeplitz correlation for irrelevant variables
Sww  <- matrix(cor,10,10) ## bloc correlation between active variables
Sigma <- bdiag(Soo,Sww,Soo,Sww,Soo)
diag(Sigma) <- 1
n <- 50
x <- as.matrix(matrix(rnorm(95*n),n,95) \%*\% chol(Sigma))
y <- 10 + x \%*\% beta + rnorm(n,0,10)

## Plot penalized criteria for the Elastic-net path
criteria(elastic.net(x,y, lambda2=1))

#' Plot penalized criteria for the Bounded regression
criteria(bounded.reg(x,y, lambda2=1))
}


## ------------------------------------------------
## Method `QuadrupenFit$plot`
## ------------------------------------------------

\dontrun{
## Simulating multivariate Gaussian with blockwise correlation
## and piecewise constant vector of parameters
beta <- rep(c(0,1,0,-1,0), c(25,10,25,10,25))
cor <- 0.75
Soo <- toeplitz(cor^(0:(25-1))) ## Toeplitz correlation for irrelevant variables
Sww  <- matrix(cor,10,10) ## bloc correlation between active variables
Sigma <- bdiag(Soo,Sww,Soo,Sww,Soo)
diag(Sigma) <- 1
n <- 50
x <- as.matrix(matrix(rnorm(95*n),n,95) \%*\% chol(Sigma))
y <- 10 + x \%*\% beta + rnorm(n,0,10)

## Plot the Lasso path
plot(elastic.net(x,y, lambda2=0), main="Lasso solution path")
## Plot the Elastic-net path
plot(enet, main = "Elastic-net solution path")
## Plot the Elastic-net path (fraction on X-axis, unstandardized coefficient)
plot(elastic.net(x,y, lambda2=10), standardize=FALSE, xvar="fraction")
## Plot the Bounded regression path (fraction on X-axis)
plot(bounded.reg(x,y, lambda2=10), xvar="fraction")
}


## ------------------------------------------------
## Method `QuadrupenFit$criteria`
## ------------------------------------------------

\dontrun{
## Simulating multivariate Gaussian with blockwise correlation
## and piecewise constant vector of parameters
beta <- rep(c(0,1,0,-1,0), c(25,10,25,10,25))
cor <- 0.75
Soo <- toeplitz(cor^(0:(25-1))) ## Toeplitz correlation for irrelevant variables
Sww  <- matrix(cor,10,10) ## bloc correlation between active variables
Sigma <- bdiag(Soo,Sww,Soo,Sww,Soo)
diag(Sigma) <- 1
n <- 50
x <- as.matrix(matrix(rnorm(95*n),n,95) \%*\% chol(Sigma))
y <- 10 + x \%*\% beta + rnorm(n,0,10)

## Plot penalized criteria for the Elastic-net path
criteria(elastic.net(x,y, lambda2=1))

#' Plot penalized criteria for the Bounded regression
criteria(bounded.reg(x,y, lambda2=1))
}

}
\references{
Ryan Tibshirani and Jonathan Taylor. Degrees of
freedom in lasso problems, Annals of Statistics, 40(2) 2012.

Ryan Tibshirani and Jonathan Taylor. Degrees of
freedom in lasso problems, Annals of Statistics, 40(2) 2012.
}
\seealso{
\code{\linkS4class{quadrupen}}.

See also \code{\link{plot.quadrupen}}.

\code{\linkS4class{quadrupen}}.
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{major_penalty}}{vector of "leading" penalties (either l1 or l2)}

\item{\code{major_penalty}}{vector of "minor" penalties (either l1 or l2)}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-QuadrupenFit-new}{\code{QuadrupenFit$new()}}
\item \href{#method-QuadrupenFit-show}{\code{QuadrupenFit$show()}}
\item \href{#method-QuadrupenFit-print}{\code{QuadrupenFit$print()}}
\item \href{#method-QuadrupenFit-predict}{\code{QuadrupenFit$predict()}}
\item \href{#method-QuadrupenFit-plot}{\code{QuadrupenFit$plot()}}
\item \href{#method-QuadrupenFit-criteria}{\code{QuadrupenFit$criteria()}}
\item \href{#method-QuadrupenFit-clone}{\code{QuadrupenFit$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-QuadrupenFit-new"></a>}}
\if{latex}{\out{\hypertarget{method-QuadrupenFit-new}{}}}
\subsection{Method \code{new()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{QuadrupenFit$new(
  x,
  y,
  coefficients,
  active.set,
  intercept,
  mu,
  normx,
  fitted,
  residuals,
  df,
  r.squared,
  penscale,
  penalty,
  naive,
  lambda1,
  lambda2,
  monitoring,
  control
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{coefficients}}{Matrix (class \code{"dgCMatrix"}) of
coefficients with respect to the original input. The number of
rows corresponds the length of \code{lambda1}.}

\item{\code{intercept}}{logical; indicates if an intercept has
been included to the model.}

\item{\code{mu}}{A vector (class \code{"numeric"})
containing the successive values of the (unpenalized) intercept.
Equals to zero if \code{intercept} has been set to \code{FALSE}.}

\item{\code{normx}}{Vector (class \code{"numeric"}) containing the
square root of the sum of squares of each column of the design
matrix.}

\item{\code{fitted}}{Matrix of fitted values, each column
corresponding to a value of \code{lambda1}.}

\item{\code{residuals}}{Matrix of residuals, each column
corresponding to a value of \code{lambda1}.}

\item{\code{df}}{Estimated degree of freedoms for the successive
\code{lambda1}.  Only available for 'elastic.net' using tCholesky
factorization.}

\item{\code{r.squared}}{Vector (class \code{"numeric"}) given the
coefficient of determination as a function of lambda1.}

\item{\code{penscale}}{Vector \code{"numeric"} with real positive
values that have been used to weight the penalty tuned by
\eqn{\lambda_1}{lambda1}.}

\item{\code{penalty}}{Object of class \code{"character"}
indicating the method used (\code{"elastic-net"} or \code{"bounded
regression"}).}

\item{\code{naive}}{logical; was the \code{naive} mode on?}

\item{\code{lambda1}}{Vector (class \code{"numeric"}) of penalty
levels (either \eqn{\ell_1}{l1} or \eqn{\ell_\infty}{l-infinity})
for which the model has eventually been fitted.}

\item{\code{lambda2}}{Scalar (class \code{"numeric"}) for the
amount of \eqn{\ell_2}{l2} (ridge-like) penalty.}

\item{\code{monitoring}}{List (class \code{"list"}) which
contains various indicators dealing with the optimization
process.}

\item{\code{control}}{Object of class \code{"list"} with low
level options used for optimization.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-QuadrupenFit-show"></a>}}
\if{latex}{\out{\hypertarget{method-QuadrupenFit-show}{}}}
\subsection{Method \code{show()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{QuadrupenFit$show()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-QuadrupenFit-print"></a>}}
\if{latex}{\out{\hypertarget{method-QuadrupenFit-print}{}}}
\subsection{Method \code{print()}}{
User friendly print method
Plot method for a quadrupen object

Produce a plot of the solution path of a \code{quadrupen} fit.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{QuadrupenFit$print()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-QuadrupenFit-predict"></a>}}
\if{latex}{\out{\hypertarget{method-QuadrupenFit-predict}{}}}
\subsection{Method \code{predict()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{QuadrupenFit$predict(newx = NULL, ...)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-QuadrupenFit-plot"></a>}}
\if{latex}{\out{\hypertarget{method-QuadrupenFit-plot}{}}}
\subsection{Method \code{plot()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{QuadrupenFit$plot(
  xvar = "lambda",
  main = paste(private$penalty, " path", sep = ""),
  log.scale = TRUE,
  standardize = TRUE,
  labels = NULL,
  plot = TRUE,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{xvar}}{variable to plot on the X-axis: either \code{"lambda"}
(\eqn{\lambda_1}{lambda1} penalty level or
\eqn{\lambda_2}{lambda2} for ridge regression) or
\code{"fraction"} (\eqn{\ell_1}{l1}-norm
of the coefficients). Default is set to \code{"lambda"}.}

\item{\code{main}}{the main title. Default is set to the model name followed
by what is on the Y-axis.}

\item{\code{log.scale}}{logical; indicates if a log-scale should be used
when \code{xvar="lambda"}. Default is \code{TRUE}.}

\item{\code{standardize}}{logical; standardize the coefficients before
plotting (with the norm of the predictor). Default is \code{TRUE}.}

\item{\code{plot}}{logical; indicates if the graph should be plotted on
call. Default is \code{TRUE}.}

\item{\code{x}}{output of a fitting procedure of the \pkg{quadrupen}
package (\code{\link{elastic.net}} or \code{\link{bounded.reg}}
for the moment). Must be of class \code{quadrupen}.}

\item{\code{y}}{used for S4 compatibility.}

\item{\code{label}}{vector indicating the names associated to the plotted
variables. When specified, a legend is drawn in order to identify
each variable. Only relevant when the number of predictor is
small. Remind that the intercept does not count. Default is
\code{NULL}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
a \pkg{ggplot2} object which can be plotted via the
\code{print} method.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
## Simulating multivariate Gaussian with blockwise correlation
## and piecewise constant vector of parameters
beta <- rep(c(0,1,0,-1,0), c(25,10,25,10,25))
cor <- 0.75
Soo <- toeplitz(cor^(0:(25-1))) ## Toeplitz correlation for irrelevant variables
Sww  <- matrix(cor,10,10) ## bloc correlation between active variables
Sigma <- bdiag(Soo,Sww,Soo,Sww,Soo)
diag(Sigma) <- 1
n <- 50
x <- as.matrix(matrix(rnorm(95*n),n,95) \%*\% chol(Sigma))
y <- 10 + x \%*\% beta + rnorm(n,0,10)

## Plot the Lasso path
plot(elastic.net(x,y, lambda2=0), main="Lasso solution path")
## Plot the Elastic-net path
plot(enet, main = "Elastic-net solution path")
## Plot the Elastic-net path (fraction on X-axis, unstandardized coefficient)
plot(elastic.net(x,y, lambda2=10), standardize=FALSE, xvar="fraction")
## Plot the Bounded regression path (fraction on X-axis)
plot(bounded.reg(x,y, lambda2=10), xvar="fraction")
}

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-QuadrupenFit-criteria"></a>}}
\if{latex}{\out{\hypertarget{method-QuadrupenFit-criteria}{}}}
\subsection{Method \code{criteria()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{QuadrupenFit$criteria(
  penalty = setNames(c(2, log(self$ncoef)), c("AIC", "BIC")),
  sigma = NULL,
  log.scale = TRUE,
  xvar = "lambda",
  plot = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{penalty}}{a vector with as many penalties a desired. The
default contains the penalty corresponding to the AIC and the BIC
(\eqn{2}{2} and \eqn{\log(n)}{log(n)}). Setting the "names"
attribute, as done in the default definition, leads to outputs
which are easier to read.}

\item{\code{sigma}}{scalar: an estimate of the residual variance. When
available, it is plugged-in the criteria, which may be more
relevant. If \code{NULL} (the default), it is estimated as usual
(see details).}

\item{\code{log.scale}}{logical; indicates if a log-scale should be used
when \code{xvar="lambda"}. Default is \code{TRUE}.}

\item{\code{xvar}}{variable to plot on the X-axis: either \code{"df"}
(the estimated degrees of freedom), \code{"lambda"}
(\eqn{\lambda_1}{lambda1} penalty level) or \code{"fraction"}
(\eqn{\ell_1}{l1}-norm of the coefficients). Default is set to
\code{"lambda"}.}

\item{\code{plot}}{logical; indicates if the graph should be plotted on
call. Default is \code{TRUE}.}

\item{\code{object}}{output of a fitting procedure of the \pkg{quadrupen}
package (e.g. \code{\link{elastic.net}}). Must be of class
\code{quadrupen}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
When \code{plot} is set to \code{TRUE}, an invisible
\pkg{ggplot2} object is returned, which can be plotted via the
\code{print} method. On the other hand, a list with a two data
frames containing the criteria and the chosen vector of parameters
are returned.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
## Simulating multivariate Gaussian with blockwise correlation
## and piecewise constant vector of parameters
beta <- rep(c(0,1,0,-1,0), c(25,10,25,10,25))
cor <- 0.75
Soo <- toeplitz(cor^(0:(25-1))) ## Toeplitz correlation for irrelevant variables
Sww  <- matrix(cor,10,10) ## bloc correlation between active variables
Sigma <- bdiag(Soo,Sww,Soo,Sww,Soo)
diag(Sigma) <- 1
n <- 50
x <- as.matrix(matrix(rnorm(95*n),n,95) \%*\% chol(Sigma))
y <- 10 + x \%*\% beta + rnorm(n,0,10)

## Plot penalized criteria for the Elastic-net path
criteria(elastic.net(x,y, lambda2=1))

#' Plot penalized criteria for the Bounded regression
criteria(bounded.reg(x,y, lambda2=1))
}

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-QuadrupenFit-clone"></a>}}
\if{latex}{\out{\hypertarget{method-QuadrupenFit-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{QuadrupenFit$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
